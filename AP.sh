#!/bin/bash
# DHCP Server / Access Point with Internet Connection
# Author: Erebus
# Version: v3.1
# Last update: 2021/09/16
# Tested on Kali Linux 2021
### Changelog ###
# - Kill the processes that might confict with the program before enabling the service
# - Add support for promiscuous mode
# - Add support for kill command (SIGTERM) setup restoration
### Future Plan ###
# - Multiple dnsmasq instances support
# - Multiple hostapd instances support
# - Multiple bridge intefaces support
# - DHCPv6 support
# - Local DNS resolution support

### Variables Initialization ###
DEPENDENCIES=( "iptables" "dnsmasq" "stdbuf" "hostapd" )
CONF_FILES=( "dnsmasq.conf" "hostapd.conf" )
CONF_DIR="$PWD"
TARGET_NIC=""
NET_NIC=""
WIRELESS_NIC=""
BRIDGE_NAME="br0"
declare -A BRIDGE_NIC
DEFAULT_GW="10.0.0.1"
# DEFAULT_GWv6="2001::1"

ap_usage() {
    echo "DHCP Server / Access Point with Internet Connection"
    echo "Usage: $0 (-b NIC1[,NIC2,...] | -i NIC1) [OPTION...] | [-h]"
    echo "  -h, --help                  Display this help menu"
    echo "  -b, --bridge (NIC1, ...)    The network interfaces you want to bridge together and assign IP addresses on"
    echo "  -i, --interface TARGET_NIC  The network interface your DHCP server is on"
    echo "  -s, --source NET_NIC        The network interface you have Internet connection on"
    echo "  -g, --gateway TARGET_GW     IP address of the gateway your DHCP server's going to use (default: $DEFAULT_GW)"
    echo "  -c, --conf-dir CONF_DIR     The direcotry for you Config files dnsmasq.conf & hostapd.conf (default: $CONF_DIR)"
    echo "  -p, --promisc               Enable promiscuous mode to intercept and read each network packet that arrives"
    echo "Prerequisites:"
    echo "  Programs: iptables, dnsmasq, stdbuf, hostapd"
}

privileged_exec() {
    # Prepend command with sudo if root privilege is required
    if [[ $EUID -ne 0 ]]; then
        sudo "$@"
    else
        "$@"
    fi
}

bridge_remove() {
    # Remove bridge interfaces
    if (( ${#BRIDGE_NIC[@]} )); then
        for key in "${!BRIDGE_NIC[@]}"
        do
            # Remove interfaces from the bridge
            privileged_exec ip link set ${BRIDGE_NIC[$key]} nomaster
            [[ " $WIRELESS_NIC " =~ " ${BRIDGE_NIC[$key]} " ]] && privileged_exec iw dev ${BRIDGE_NIC[$key]} set 4addr off
            [ "${key%%,*}" = "$bridge" ] && duplicate=true || duplicate=false
            bridge=${key%%,*}
            if [ "$duplicate" = false ]; then
                privileged_exec ip link delete $bridge type bridge
            fi
        done
        unset bridge duplicate
    fi
}

firewall_rules_restore() {
    # Clean up the iptables rules and forwarding capabilities
    if [ -n "$NET_NIC" ]; then
        privileged_exec iptables -t nat -D POSTROUTING -o ${NET_NIC} -j MASQUERADE
        privileged_exec iptables -D FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
        privileged_exec iptables -D FORWARD -i ${TARGET_NIC} -o ${NET_NIC} -j ACCEPT
        privileged_exec ip addr flush $TARGET_NIC
        privileged_exec ip link set dev ${NET_NIC} promisc off
        privileged_exec sysctl net.ipv4.ip_forward=0 >/dev/null
        echo 0 | privileged_exec tee /proc/sys/net/ipv4/conf/$NET_NIC/forwarding | cat >/dev/null
    fi
}

service_stop() {
    local x pid
    # Stop all the running services
    for x in $CONF_DIR/*.pid; do
        if [[ -f $x ]] &&  sleep 0.3  && [[ -f $x ]]; then
            pid=$(cat $x)
            privileged_exec pkill -P $pid 2>/dev/null
            privileged_exec kill $pid 2>/dev/null
            [[ -f $x ]] && rm $x 2>/dev/null
        fi
    done

    [[ -f $CONF_DIR/dnsmasq.leases ]] && privileged_exec rm $CONF_DIR/dnsmasq.leases
    wait
}

service_cleanup() {
    printf "\nSIGINT caught..."
    echo "Cleaning up all running services and configs..."
    service_stop

    if [ "$PROMISC" = true ] ; then
        privileged_exec ip link set ${TARGET_NIC} promisc off
    fi

    if [ -n "$WIRELESS_NIC" ]; then
        privileged_exec service NetworkManager restart
    fi

    firewall_rules_restore
    bridge_remove
    echo DONE

    # If sourced by another script, let another script add their own trap to Ctrl+C and exit itself
    if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
        exit 0
    fi
}

requirement_check() {
    # Check if required dependencies are installed on the system
    for dependency in ${DEPENDENCIES[@]}
    do
        if [[ ! -x $(privileged_exec which $dependency) ]]; then
            echo "[ERROR] Required program $dependency not found." >&2
            exit 1
        fi
    done

    # Check if assigned direcotory contains the required configs
    for CONF in ${CONF_FILES[@]}
    do
        if [[ ! -f "$CONF_DIR/$CONF" ]]; then
            echo "[ERROR] Config file $CONF not found in the target directory ($CONF_DIR)." >&2
            exit 1
        fi
    done

    # Check if target network interface is assigned
    [[ -z "$TARGET_NIC" ]] && { echo "[ERROR] Target network interface has to be assigned with (-b NIC1[,NIC2,...] | -i NIC1)" >&2; exit 1; }
}

is_interface() {
    # Check if the assigned interface exists
    [[ -z "$1" ]] && return 1
    [[ -d "/sys/class/net/${1}" ]]
}

is_wireless_interface() {
    privileged_exec which iw > /dev/null 2>&1 && privileged_exec iw dev $1 info > /dev/null 2>&1 && return 0
    if privileged_exec which iwconfig > /dev/null 2>&1 && privileged_exec iwconfig $1 > /dev/null 2>&1; then
        return 0
    fi
    return 1
}

gateway_setup() {
    [[ -z "$TARGET_GW" ]] && TARGET_GW=$DEFAULT_GW
    # TODO: DHCPv6 support
    # TARGET_GWv6=$DEFAULT_GWv6
    # TODO: Multiple dnsmasq instances support
    # Set up a new gateway IP address for the interface
    # if [ -z $TARGET_GW ]; then
    #     TARGET_GW+=( $DEFAULT_GW )
    # else
    #     IFS="." read -r a b c d <<< ${TARGET_GW[-1]}
    #     TARGET_GW+=( "$a.$b.$(($c+1)).$d" )
    # fi
}

internet_sharing() {
    # Set up the interface and firewall rules for internat sharing
    privileged_exec ip link set dev ${NET_NIC} promisc on
    privileged_exec iptables -t nat -A POSTROUTING -o ${NET_NIC} -j MASQUERADE
    privileged_exec iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
    privileged_exec iptables -A FORWARD -i ${TARGET_NIC} -o ${NET_NIC} -j ACCEPT
    # echo 1 > /proc/sys/net/ipv4/ip_forward
    privileged_exec sysctl net.ipv4.ip_forward=1 >/dev/null
    echo 1 | privileged_exec tee /proc/sys/net/ipv4/conf/$NET_NIC/forwarding | cat >/dev/null
    # To enable clients to establish PPTP connections
    privileged_exec modprobe nf_nat_pptp > /dev/null 2>&1
}

bridge_setup() {
    # Bridge the interfaces
    for key in "${!BRIDGE_NIC[@]}"
    do
        [ "${key%%,*}" = "$bridge" ] && duplicate=true || duplicate=false
        bridge=${key%%,*}
        if [ "$duplicate" = false ]; then
            # Add new bridges
            privileged_exec ip link add name $bridge type bridge
            privileged_exec ip link set $bridge up
            # Set 0ms forward delay
            echo -n 0 | privileged_exec tee /sys/class/net/$bridge/bridge/forward_delay | cat /dev/null
        fi
        [[ " $WIRELESS_NIC " =~ " ${BRIDGE_NIC[$key]} " ]] && privileged_exec iw dev ${BRIDGE_NIC[$key]} set 4addr on
        privileged_exec ip link set ${BRIDGE_NIC[$key]} up
        # Add interfaces to the bridge
        privileged_exec ip link set ${BRIDGE_NIC[$key]} master $bridge
    done
    unset bridge duplicate
}

network_init() {
    # Initialize the network interface for DHCP leases
    privileged_exec ip link set down dev $TARGET_NIC
    privileged_exec ip addr flush $TARGET_NIC
    privileged_exec ip link set up dev $TARGET_NIC
    privileged_exec ip addr add $TARGET_GW/24 broadcast ${TARGET_GW%.*}.255 dev $TARGET_NIC
    # Enable promiscuous mode if assigned
    if [ "$PROMISC" = true ] ; then
        privileged_exec ip link set ${TARGET_NIC} promisc on
    fi
    # TODO: DHCPv6 support
    # ip -6 addr add $TARGET_GWv6/64 dev $TARGET_NIC
	# Assign the specified network interface and gateway to dnsmasq config file
	privileged_exec sed -i "s/^interface.*/interface=$TARGET_NIC/g" $CONF_DIR/dnsmasq.conf
	privileged_exec sed -i "s/^dhcp-option=3.*/dhcp-option=3, $TARGET_GW/g" $CONF_DIR/dnsmasq.conf
    privileged_exec sed -i "s/^dhcp-option=6.*/dhcp-option=6, $TARGET_GW/g" $CONF_DIR/dnsmasq.conf
    privileged_exec sed -i "s/^dhcp-range=.*/dhcp-range=${TARGET_GW%.*}.10,${TARGET_GW%.*}.20,255.255.255.0/g" $CONF_DIR/dnsmasq.conf
    # Assign the wireless interface and bridge interface to hostapd config file
    if [ -n "$WIRELESS_NIC" ]; then
    	sed -i "s/^interface.*/interface=$WIRELESS_NIC/g" $CONF_DIR/hostapd.conf
        if (( ${#BRIDGE_NIC[@]} )); then
            # Uncomment and assign the bridge interface
            privileged_exec sed -i '/bridge=/s/^#//g' $CONF_DIR/hostapd.conf
            privileged_exec sed -i "s/^bridge=.*/bridge=$TARGET_NIC/g" $CONF_DIR/hostapd.conf
        else
            # Comment out the line for bridge interface
            privileged_exec sed -e '/bridge=/ s/^#*/#/' -i $CONF_DIR/hostapd.conf
        fi
    fi
}

kill_conflict() {
    # Kill all the processes that might conflict with the program
    privileged_exec killall dhclient wpa_supplicant NetworkManager 2>/dev/null
}

service_enable() {
	# Enable the DHCP server
    # TODO: Local DNS resolution support
    # -p $DNS_PORT
    echo "Enabling DHCP Server / Access Point..."
    if [ -n "$WIRELESS_NIC" ]; then
        SSID=$(sed -n 's/^ssid=*//p' $CONF_DIR/hostapd.conf)
        echo "Enabling Access Point with SSID \"$SSID\""
    fi
    privileged_exec dnsmasq -C $CONF_DIR/dnsmasq.conf -x $CONF_DIR/dnsmasq.pid -l $CONF_DIR/dnsmasq.leases
	if [ -n "$WIRELESS_NIC" ]; then
		privileged_exec stdbuf -oL hostapd $CONF_DIR/hostapd.conf &
        HOSTAPD_PID=$(privileged_exec pgrep -x hostapd 2>/dev/null)
        echo $HOSTAPD_PID > $CONF_DIR/hostapd.pid
	fi
}

print_lease_change() {
    # Print out the DHCP leases if there are any changes
    m1=$(md5sum "$CONF_DIR/dnsmasq.leases")
    while :; do
        sleep 5
        m2=$(md5sum "$CONF_DIR/dnsmasq.leases")
        if [ "$m1" != "$m2" ] ; then
            echo "--------------------------------------------------"
            cat "$CONF_DIR/dnsmasq.leases"
            echo "--------------------------------------------------"
            m1="$m2"
        fi
    done
}

initialization() {
    kill_conflict

    if [ -n "$NET_NIC" ]; then
        echo "Enabling NAT and IP forward for Internet Sharing..."
        internet_sharing
    fi

    # Set up the bridge interface if assigned
    (( ${#BRIDGE_NIC[@]} )) && bridge_setup
    echo "Initializing the network interface..."
    network_init
}

argument_parse() {
    while [ "$1" != "" ]; do
        case $1 in
            -b | --bridge )         shift
                                    [ -z "$1" ] && { ap_usage; exit 1; }
                                    num=0
                                    for i in ${1//,/ }
                                    do
                                        # Exit the program if the interface does not exist
                                        is_interface "$i" || { echo "[ERROR] Interface \"$i\" not exist!" >&2; exit 1; }
                                        # Automatically detect if it is a wireless interface
                                        # TODO: Multiple hostapd instances support
                                        # is_wireless_interface "$i" && WIRELESS_NIC+=( $i )
                                        is_wireless_interface "$i" && WIRELESS_NIC=$i
                                        # Append the valid interface to the bridge interface
                                        [ -z $BRIDGE_NIC ] && BRIDGE_NIC[$BRIDGE_NAME,$num]="$i" || BRIDGE_NIC+=( [$BRIDGE_NAME,$num]="$i" )
                                        ((num++))
                                    done
                                    unset num
                                    # Append the bridge interface to the target interface for DHCP lease
                                    # TODO: Multiple dnsmasq instances support
                                    # TARGET_NIC+=( $BRIDGE_NAME )
                                    TARGET_NIC=$BRIDGE_NAME
                                    # Assign a new bridge name if there is any to be created (e.g. br0 -> br1)
                                    # [[ ${BRIDGE_NAME} =~ ([^0-9]*)([0-9]+) ]]
                                    # BRIDGE_NAME="${BASH_REMATCH[1]}$(( ${BASH_REMATCH[2]} + 1 ))"
                                    gateway_setup
                                    ;;
            -i | --interface )      shift
                                    [[ -z "$1" ]] && { ap_usage; exit 1; }
                                    # Exit the program if the interface does not exist
                                    is_interface "$1" || { echo "[ERROR] Interface \"$1\" not exist!"; exit 1; }
                                    # Automatically detect if it is a wireless interface
                                    is_wireless_interface "$1" && WIRELESS_NIC=$1
                                    # Append the interface to the target interface for DHCP lease
                                    TARGET_NIC=$1
                                    gateway_setup
                                    ;;
            -s | --source )     	shift
                                    [[ -z "$1" ]] && { ap_usage; exit 1; }
                                    is_interface "$1" || { echo "[ERROR] Interface \"$1\" not exist!"; exit 1; }
                                    NET_NIC=$1
                                    ;;
            -g | --gateway )        shift
                                    [[ -z "$1" ]] && { ap_usage; exit 1; }
                                    TARGET_GW=$1
                                    ;;
            -c | --conf-dir )       shift
                                    [[ -z "$1" ]] && { ap_usage; exit 1; }
                                    [[ ! -d $1 ]] && { echo "[ERROR] Direcotory \"$1\" not found!"; exit 1; }
                                    # Convert the config path to absolute path
                                    CONF_DIR=$(realpath $1)
                                    ;;
            -p | --promisc )        PROMISC=true
                                    ;;
            -h | --help )           ap_usage
                                    exit
                                    ;;
            * )                     ap_usage
                                    exit 1
        esac
        shift
    done
}

main() {
    # If no arguments provided
    if [[ $# -eq 0 ]] ; then
        ap_usage
        exit 0
    fi
    argument_parse "$@"
    requirement_check
    initialization
    service_enable
    print_lease_change
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    trap service_cleanup SIGINT SIGTERM
    main "$@"
fi
